Тип данных – характеристика переменной или константы, определяющая, какого рода значение хранится в отведенной для нее области памяти
Java – строго типизированный язык, из чего следует, что любая переменная перед ее использованием должна быть объявлена с указанием типа
Встроенные типы в Java делятся на две категории: примитивные и ссылочные
 Примитивны типы в Java называются с маленькой буквы (например, byte, long, int)
Примитивные типы данных – это базовые типы данных языка программирования. Их ключевая особенность в том, что данные в них, в отличие от ссылочных типов, располагаются непосредственно на участке памяти компьютера в котором находится переменная.
Различают целые, вещественные, символьные, логические
Ссылочные обозначаются с большой буквы (например, массивы, классы).
Самая важная особенность ссылочных типов данных состоит в том, что они передаются не по значению, а по ссылке.
Ссылочные типы данных не являются примитивными и их размер не фиксирован и может быть произвольным, кроме того они хранятся не на участке памяти переменной, а в совершенно другом месте памяти компьютера. Ссылочными типами, например, являются массивы. В объектно-ориентированных языках программирования – это экземпляры классов, коллекции и тому подобное. Память в компьютере для созданного объекта выделяется с помощью оператора new, а в переменную объекта заносится лишь ссылка на участок памяти, в котором располагается созданный объект. Передавая объект в качестве аргумента методу (или функции), в метод передаётся лишь копия адреса, но не копия объекта.
Типы-обертки
Для представления примитивных типов как объектов было сделаны классы-обертки. Преимущества:
 1. возможность использования объектов классов-оберток в качестве параметров к методам
 2.Возможность использования констант, которые отвечают за границы соответствующего типа данных (MIN_VALUE и MAX_VALUE)
 3.возможность использования методов для преобразования в другие примитивные типы, конвертации между системами счисления
Autoboxing и unboxing процесс автоматической запаковки(распаковки) примитивных типов в оболочку
// Integer i1 = new Integer (“10”);
// Integer i2 = new Integer(10);
Массивы
Массив это объект, хранящий в себе фиксированное количество значений одного типа. Другими словами, массив — это нумерованный набор переменных. Переменная в массиве называется элементом массива, а ее позиция в массиве задается индексом. Например, int[] myFirstArray
Null
Был изобретен для обозначения отсутствия чего-либо, например, отсутствие пользователя, ресурса или чего угодно.
Каждый примитив имеет значение по умолчанию, например, у int это 0, у boolean это false
Null может быть назначен только ссылочному типу, Вы не можете назначить null примитивной переменной вроде int, double, float или boolean.
Любой класс-обертка со значением null будет выбрасывать java.lang.NullPointerException когда Java распакует(unbox) его в примитивную переменную.!!!На вершине иерархии классов находится класс Object, который является суперклассом для всех классов. Ссылочная переменная типа Object может указывать на объект любого другого класса, на любой массив, так как массивы реализуются как классы. В классе Object определен набор методов, который наследуется всеми классами.
Метод to String необходим для представления данного объекта в виде строки. Его нередко переопределяют, так как при попытке вывести строковое представление какого-либо объекта будет выведено полное имя класса, что не всегда хорошо.
Зачем нужны методы equals & hashCode?
используются для сравнения объектов.
Цель метода equals – определить идентичны ли объекты внутри, сравнив внутреннее содержание объектов.
Тк equals работает медленно, сначала сравниваются хэш коды объектов, и, в том случае, если хэш коды равны, идет проверка по equals
Что будет, если переопределить equals, но не переопределить hashCode?
изначально hashCode — случайное число.
Коллекции в Java перед тем как сравнить объекты с помощью equals всегда ищут/сравнивают их с помощью метода hashCode(). И если у одинаковых объектов будут разные hashCode, то объекты будут считаться разными — до сравнения с помощью equals просто не дойдет.!!!Java обеспечивает контроль доступа через три модификатора — public, protected and private. Мы не обязаны использовать эти модификаторы доступа всегда, поэтому у нас есть еще модификатор доступа по умолчанию, а именно default access, package-private или no modifier.
Мы можем использовать модификаторы доступа с классами, а также переменными класса и методами.
Модификатор public
Если член класса «public», то он может быть использован в любом месте. Переменная или метод имеет доступ в глобальном масштабе. Это простой способ обеспечить доступ к членам класса, однако мы должны заботиться в использовании этого ключевого слова/модификатора с переменными класса, в противном случае кто-нибудь может изменить значения. Обычно переменные класса private, а доступ к этим переменным осуществляется через getter-setter методы.
Модификатор private
Если член класса «private», то он будет доступен только внутри того же класса. Это наиболее ограниченный доступ, поэтому член класса не будет виден для внешнего мира. Обычно переменные класса и методы, предназначенные для использования только внутри класса, делают private.
Модификатор protected
Если член класса «protected», то он будет доступен только для классов в одном пакете и в подклассах. Этот модификатор менее ограничен, чем private, но более ограничен, чем public. Обычно мы используем это ключевое слово/модификатор, чтобы убедиться, что переменные класса доступны только для подклассов.

Модификатор package-private

default (модификатор, по-умолчанию)члены класса видны внутри пакета (если класс будет так объявлен он будет доступен только внутри пакета)!!!•	Интерфейс — это договорные отношения с классами, которые этот интерфейс реализуют, о том, что реализация происходит путём, обозначенным интерфейсом. Это пустая оболочка с объявленными методами.
	Абстрактный класс определяет некоторое общее поведение и просит свои подклассы определить нетипичное или конкретное поведение для своего класса.
	Класс содержит как данные, так и программный код, манипулирующий этими данными.
	Методы и члены абстрактного класса могут быть обозначены любым модификатором доступа, в свою очередь все методы интерфейса обязаны быть открытыми (public).
	Интерфейс не содержит конструкторы, в том время, как они есть в абстрактном классе.
	Переменные, объявленные в Java-интерфейсе по умолчанию являются final. Абстрактный класс может содержать переменные, которые не являются final.
	Все участники Java-интерфейса по умолчанию являются public. Участники абстрактного класса могут позволить себе быть public, protected и др.!!!Кроме обычных методов и полей класс может иметь статические поля и методы. Например, главный класс программы имеет метод main, который является статическим:


Иногда желательно определить член класса, который будет использоваться не¬ зависимо от любого объекта этого класса. Как правило, обращение к члену класса должно осуществляться только в сочетании с объектом его класса. Но можно создать член класса, чтобы пользоваться им отдельно, не ссылаясь на конкретный экземпляр. Чтобы создать такой член, в начале его объявления нужно разместить ключевое сло¬во static. Когда член класса объявлен как static (статический), он доступен до соз¬дания любых объектов его класса и без ссылки на какой-нибудь объект. Статическими могут быть объявлены как методы, так и переменные. Наиболее распространенным примером статического члена служит метод main ( ) , который объявляется как static, поскольку он должен быть объявлен до создания любых объектов. При объявлении объектов класса этих переменных их копии не соз¬даются. Вместо этого все экземпляры класса совместно используют одну и ту же статическую переменную. На методы, объявленные как static, накладывается следующие ограничения:
• Они могут непосредственно вызывать только другие статические методы.
• Им непосредственно доступны только статические переменные.
• Они никоим образом не могут делать ссылки типа this
Если для инициализации статических переменных требуется произвести вы¬числения, то для этой цели достаточно объявить статический блок, который будет выполняться только один раз при первой загрузке класса.
За пределами класса, в котором определены статические методы и перемен¬ные, ими можно пользоваться независимо от любого объекта. Для этого достаточ¬но указать имя их класса через операцию-точку непосредственно перед их имена¬ми. Так, если требуется вызвать статический метод за пределами его класса, это можно сделать, используя следующую общую форму: имя_класса. метод ( )!!!Поле может быть объявлено как final (финальное). Это позволяет предотвратить изменение содержимого переменной, по сути, это становится константой. Финальное поле должно быть инициализировано во время его первого объявления. Теперь можно пользоваться переменной так, как если бы она была константой, без риска изменения их значений. Принято записывать имена заглавными буквами.
Кроме полей, final можно использовать для параметров метода (препятствует изменению в пределах метода) и у локальных переменных (препятствует присвоению ей значения более одного раза).
Также слово final можно применять к методам, чтобы предотвратить его переопределение.
Ещё один вариант использования ключевого слова final - предотвращение наследования класса. При этом неявно всего методы класса также становятся финальными. Поэтому нельзя одновременно объявить класс абстрактным и финальным, поскольку абстрактный класс является лишь шаблоном и только его подклассы реализуют методы.!!!Лямбды
Лямбда представляет набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.
Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.
Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

Чтобы объявить и использовать лямбда-выражение, основная программа разбивается на ряд этапов:
	Определение ссылки на функциональный интерфейс:
	Operationable operation;
	Создание лямбда-выражения:
        operation = (x,y)->x+y;
	Причем параметры лямбда-выражения соответствуют параметрам единственного метода интерфейса Operationable, а результат соответствует возвращаемому результату метода интерфейса. При этом нам не надо использовать ключевое слово return для возврата результата из лямбда-выражения.
	Так, в методе интерфейса оба параметра представляют тип int, значит, в теле лямбда-выражения мы можем применить к ним сложение. Результат сложения также представляет тип int, объект которого возвращается методом интерфейса.
	Использование лямбда-выражения в виде вызова метода интерфейса:	int result = operation.calculate(10, 20);
	Так как в лямбда-выражении определена операция сложения параметров, результатом метода будет сумма чисел 10 и 20.
При этом для одного функционального интерфейса мы можем определить множество лямбда-выражений.!!!Вложенные классы в Java объявляются в теле другого класса. Вложенный класс может иметь модификатор доступа private, public, protected, тогда как внешний класс может иметь только public или default .
Вложенные классы делятся на два типа:
Статический вложенный класс
Статические вложенные классы могут обращаться только к статическим членам внешнего класса. Статический вложенный класс такой же, как и любой другой класс верхнего уровня и является вложенным только для удобства упаковки.
Статические объекты класса могут быть созданы с следующим образом:
Внутренний класс Java
Любой не-статический вложенный класс известен как внутренний класс. Внутренние классы связаны с объектом класса, и они могут получать доступ ко всем переменным и методам внешнего класса. Объект внутреннего класса являются частью объекта внешнего класса. Чтобы создать экземпляр внутреннего класса, мы должны сначала создать экземпляр внешнего класса.
Есть два специальных вида внутренних классов Java.
Локальные внутренние классы
Если класс определяется в теле метода, то его называют локальным внутренним классом. В таких классах допускаются только модификаторы abstract или final. Локальный внутренний класс может получить доступ ко всем членам внешнего класса и локальных final-переменных.
Внутренний анонимный класс
Локальный внутренний класс без имени известен как анонимный внутренний класс. Анонимный класс определяется и конкретизируется в одном заявлении. Анонимный внутренний класс всегда расширяет класс или реализовывает интерфейс. Так как анонимный класс не имеет имени, то не возможно определить конструктор для анонимного класса. Анонимные внутренние классы доступны только в точке, где она определена.!!!При возникновении ошибки выполнение программы приостанавливается и в соответствии с типом ошибки, которая возникла, создается объект, который описывает эту ошибку. Такой объект обычно называют исключением. Далее исключение передается для обработки тому методу, который вызвал ошибку. Если метод обрабатывает исключение, то дальнейшее выполнение программы контролируется способом обработки возникшего исключения. Если метод не обрабатывает исключение, то оно передается внешнему методу (тому, который вызвал метод, который, в свою очередь, вызвал ошибку). Если внешний метод тоже не обрабатывает ошибку, то так будет продолжаться по цепочке, до тех пор, пока исключение не будет обработано. В конце концов вызовется обработчик по умолчанию, следствием работы которого является досрочное завершение работы программы.
Для работы с исключениями в Java предлагается система вложенных классов, в вершине которой располагается класс Throwable. У этого класса имеется два подкласса Erorr и Exception.
Подкласс Erorr соответствует как раз тем ошибкам, которые обрабатывать программными методами бесполезно – это фатальные ошибки (например, переполнение стека).
 С ошибками подкласса Exception можно работать. Например, подкласс RuntimeExeption, в свою очередь, имеет подклассы, которые соответствуют стандартным ошибкам при выполнении программы (например, деление на 0 или выход за пределы массива).
Контролируемые и неконтролируемые исключения отличаются важной особенностью. Если метод может выбрасывать (генерировать) контролируемое исключение, и обработка этого исключения в методе не предусмотрена, то в сигнатуре этого метода необходимо указать ключевое слово throws и имя класса контролируемого исключения.!!!В простейшей форме перечисление - это список именованных констант. Но в Java перечисления имеют более сложный функционал, чем в других языках программирования. Они могут иметь конструкторы, методы и переменные экземпляра.
Перечисления создаются с использованием ключевого слова enum.Вы можете присвоить переменной только те значения, которые определены в перечислении.!!!Реализация интерфейса предполагает, что с помощью вызова метода next() можно получить следующий элемент. С помощью метода hasNext() можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. И если элементы еще имеются, то hasNext() вернет значение true. Метод hasNext() следует вызывать перед методом next(), так как при достижении конца коллекции метод next() выбрасывает исключение NoSuchElementException. И метод remove() удаляет текущий элемент, который был получен последним вызовом next().!!!Для хранения наборов данных в Java предназначены массивы. Однако их не всегда удобно использовать, прежде всего потому, что они имеют фиксированную длину. Эту проблему в Java решают коллекции. Однако суть не только в гибких по размеру наборах объектов, но в и том, что классы коллекций реализуют различные алгоритмы и структуры данных, например, такие как стек, очередь, дерево и ряд других.
Классы коллекций располагаются в пакете java.util, поэтому перед применением коллекций следует подключить данный пакет.
Хотя в Java существует множество коллекций, но все они образуют стройную и логичную систему. Во-первых, в основе всех коллекций лежит применение того или иного интерфейса, который определяет базовый функционал.Интерфейс Collection является обобщенным и расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в цикле по типу for-each.
Все эти и остальные методы, которые имеются в интерфейсе Collection, реализуются всеми коллекциями, поэтому в целом общие принципы работы с коллекциями будут одни и те же. Так, добавление элемента будет производиться с помощью метода add, который принимает добавляемый элемент в качестве параметра.
Метод clear будет очищать коллекцию, а метод size возвращать количество элементов в коллекции!!!Интерфейс Список (List)
Список представляет собой упорядоченный набор элементов и может содержать повторяющиеся элементы. Вы можете получить доступ к любому элементу по индексу. Список представляет собой динамический массив. Список является одним из наиболее используемых типов коллекций. ArrayList и LinkedList классы являются реализацией интерфейса List.



Класс ArrayList представляет обобщенную коллекцию, которая наследует свою функциональность от класса AbstractList и применяет интерфейс List. Проще говоря, ArrayList представляет простой список, аналогичный массиву, за тем исключением, что количество элементов в нем не фиксировано.Емкость в ArrayList представляет размер массива, который будет использоваться для хранения объектов. При добавлении элементов фактически происходит перераспределение памяти - создание нового массива и копирование в него элементов из старого массива. Изначальное задание емкости ArrayList позволяет снизить подобные перераспределения памяти, тем самым повышая производительность.!!!Набор представляет собой коллекцию, которая не может содержать повторяющиеся элементы. Этот интерфейс представляет математическую абстракцию для представления множеств в виде колоды карт.
Платформа Java содержит три реализации Set : HashSet, TreeSet и LinkedHashSet.Интерфейс Set не позволяет осуществлять произвольный доступ к элементу в коллекции. Мы можем использовать итератор или цикл по каждому элементу для перебора элементов.
Обобщенный класс HashSet<E> представляет хеш-таблицу. Он наследует свой функционал от класса AbstractSet, а также реализует интерфейс Set.
Хеш-таблица представляет такую структуру данных, в которой все объекты имеют уникальный ключ или хеш-код. Данный ключ позволяет уникально идентифицировать объект в таблице.
Обобщенный класс TreeSet<E> представляет структуру данных в виде дерева, в котором все объекты хранятся в отсортированном виде по возрастанию. EnumSet расширяет класс AbstractSet. Используется с перечислениями. Это высоко производительная реализация интерфейса Set для перечислений.
EnumSet может быть использован как заменитель традиционного набора битовых флагов «bit flags».
Множество EnumSet должено содержать элементы только из одного перечисления.
Итератор проходит EnumSet в порядке ввода элементов в набор, что называется естественным порядком. Итератор может проходить по интервалу элементов перечисления (именно перечисления, а не набора) или по всем элементам набора.
Null элементы запрещены, но проверка на наличие таковых элементов или удаление элемента допускаются.
EnumSet не синхронизирован. Базовые операции выполняются за постоянное время.
В общем случае EnumSet работает быстрее, чем HashSet.!!!Отображения представляют такие наборы, в которых каждый объект представляет пару "ключ-значение". Такие коллекции облегчают поиск элемента, если нам известен ключ - уникальный идентификатор объекта.Чтобы положить объект в коллекцию, используется метод put, а чтобы получить по ключу - метод get. Реализация интерфейса Map также позволяет получить наборы как ключей, так и значений.Отображения в Java представлены несколькими классами. Базовым классом для всех отображений является абстрактный класс AbstractMap, который реализует большую часть методов интерфейса Map. Наиболее распространенным классом отображений является HashMap, который реализует интерфейс Map и наследуется от класса AbstractMap.EnumMap
Высоко производительное отображение (map).
В качестве ключей используются элементы перечисления, что позволяет реализовывать EnumMap на базе массива.
Null ключи запрещены. Null значения допускаются.
Все основные операции с EnumMap совершаются за постоянное время. Как правило EnumMap работает быстрее, чем HashMap.!!!Интерфейс Queue
Обобщенный интерфейс Queue<E> расширяет базовый интерфейс Collection и определяет поведение класса в качестве однонаправленной очереди. Таким образом, у всех классов, которые реализуют данный интерфейс, будет метод offer для добвления в очередь, метод poll для извлечения элемента из головы очереди, и методы peek и element, позволяющие просто получить элемент из головы очереди.Интерфейс Deque
Интерфейс Deque расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO (последний вошел - первый вышел).Существует также класс LinkedList имеющий больше операций, чем ArrayList, а значит более сложный и требующий больше памяти. Класс представляет структуру данных связного списка и реализует интерфейсы List, Dequeue, Queue.
Операции вставки и удаления в середине списка работают у него эффективнее. Но хуже обстоит дело с операциями произвольного доступа.
Для добавления элемента в конец списка используется метод add(), для удаления используется метод remove().!!!В условиях использования компьютерных информационных технологий актуальны вопросы организации взаимодействия человека с техническими и программными средствами. Такое взаимодействие обеспечивает пользовательский интерфейс.
К общим принципам, лежащим в основе графического пользовательского интерфейса, относятся: графический режим работы; - представление ряда объектов пиктограммами, многооконность, использование указывающего устройства – мыши, адекватность изображения на экране изображаемому объекту (принцип WYSIWIG - What You See Is What You Get), наглядность; - стандартизация всех основных действий и элементов. (Все программы для данной графической среды выглядят и ведут себя совершенно одинаково, используют одинаковые принципы функционирования); наличие большого числа стандартных элементов (кнопок, полей редактирования, переключателей и т.д.), которые могут использоваться при конструировании ПС, делая их похожими в обращении и облегчая процесс их написания.
Пользовательский интерфейс включает три основных компонента:
общение приложения с пользователем;
общение пользователя с приложением;
язык общения.
Графический интерфейс пользователя GUI-приложения всегда имеют главное окно
 Окно может включать в себя разнообразную графическую информацию законченные элементы графического интерфейса - компоненты
Взаимодействие «приложение пользователь» осуществляется через:
содержимое окна, содержимое компонентов, дополнительные окна
 Взаимодействие «пользователь приложение» осуществляется через механизм событий
Механизм взаимодействия «пользователь приложение»
 Консольное приложение
Если требуется получить информацию от пользователя, вызывается соответствующая функция, после чего приложение ждет ответа от пользователя через консоль
Главная нить все время ждет новых событий, большинство из которых связано с действиями пользователя, произошедшие события обрабатываются
Длительные действия выполняются в других нитях
Приложение может не иметь консоли!!!Есть две основных библиотеки графических утилит, которые используются при создании графического интерфейса для приложений в Java. AWT(Abstract Window Toolkit) и Swing.
Элементы графического интерфейса можно создавать как на основе утилит AWT(“Тяжелые” компоненты), так и на основе Swing(“Легкие” компоненты). Элементы Swing Обладают большей гибкостью и разнообразием свойств.
Все элементы графического интерфейса можно разделить на два типа: контейнеры и компоненты. Контейнеры, в свою очередь, делятся на две категории. Первую небольшую группу формируют контейнеры верхнего уровня (им соответствуют классы JFrame, JWindow, JDialog, JApplet). Эти классы являются потомками класса Container библиотеки AWT и их относят к тяжеловесным. Вторую многочисленную группу контейнеров относят к легковесным и  они являются потомками класса JComponent.
Для создания прочих элементов, таких как окна, кнопки, переключатели, метки, полосы, прокрутки, поля ввода, меню используются специальные классы, входящие в библиотеку Swing.!!!В результате действий пользователя окно может полностью или частично скрываться и затем открываться снова, поэтому окно должно иметь возможность отобразить свое содержимое в любой момент работы приложения
В тот момент, когда графическая оболочка считает, что окно должно быть перерисовано, вызывается его метод paint
Программа может сама вызвать перерисовку своего окна целиком или частично, вызвав метод repaint
repaint(); или repaint(x, y, width, height);
В этом методе окно всегда должно быть перерисовано полностью, фактически, отрисовка осуществляется не на экране, а в памяти ЭВМ
 После этого область, которую необходимо перерисовать, копируется из памяти на экран
Пиксел (pixel) - атомарный элемент графического изображения, квадрат с маленькими сторонами, каждый пиксел может иметь свой цвет, пикселы имеют целочисленные координаты:
0<=x <= x max,  0<= y< Ymax
Все элементы изображения складываются из пикселей.  Цвет пикселя задается интенсивностями красного, зеленого и синего цвета, в диапазоне от 0 до 255 (Color color = new Color(r, g, b);)
Для цвета может быть задана прозрачность (alpha) в диапазоне от 0 до 255. 255 - непрозрачный цвет, 0 - полностью прозрачный цвет (не будет виден)
Текущий цвет, используемый при рисовании, выбирается отдельным методом setColor класса Graphics ? Кроме этого, может быть выбран цвет фона окна, для этого используется метод setBackground класса Component.
Если метод paint фрейма Swing переопределен, то перерисовка осуществляется на основном фрейме
Попытка изменить фон вызовом метода setBackground также изменяет фон основного фрейма
 В некоторых случаях содержимое contentPane затирает собой на экране содержимое основного фрейма!!!Современный подход к обработке событий основан на модели делегирования событий (delegation event model ), определяющей стандартные и согласованные механизмы для создания и обработки событий. Его концепция проста: источник извещает о событии одного или несколько слушателей (listener). В этой схеме слушатель просто ожидает до тех пор, пока не получит извещение о событии. Как только извещение о событии получено, слушатель обрабатывает его и возвращает управление. Преимущество такого дизайна в том, что логика приложения, обрабатывающего события, четко отделена от логики пользовательского интерфейса, извещающего об этом событии. Элемент пользовательского интерфейса может “делегировать” обработку события отдельному фрагменту кода. В модели делегирования событий слушатели должны регистрироваться источником для того, чтобы получать извещения о событиях.
В модели делегирования событие — это объект, описывающий изменение состояния источника. Он может быть создан в результате взаимодействия пользователя с элементом графического интерфейса. К событиям приводят такие действия, как щелчок на экранной кнопке, ввод символа с клавиатуры, выбор элемента в списке и щелчок кнопкой мыши.
Методы, принимающие и обрабатывающие события, определены в наборе интерфейсов, находящихся в пакете java.awt.event.
Например, интерфейс MouseMotionListener определяет два метода для получения уведомлений о перетаскивании объекта или перемещении мыши.!!!Особенность компоновки GUI форм в Java заключается в том, что необходимо использовать менеджеры Layout. Они определяют размер и расположение компонентов, а так же при изменении размера окна пропорционально масштабируют компоненты формы, эта особенность обусловлена тем, что код Java может запускаться на разных ОС с разными разрешением экрана, поэтому могут возникнуть проблемы при их отображении. Менеджеры компоновки Layout в Swing применяются для компонентов(JFrame,JPanel,JButton и др.).
Для установки менеджера компоновки необходимо воспользоваться методом setLayout(), который определен в классе Container.
BorderLayout
По умолчанию в Swing используется менеджер BorderLayout ,в нем определены следующие константы для установки компонентов.
BorderLayout.NORTH (верх)
BorderLayout.SOUTH (низ)
BorderLayout.EAST (справа)
BorderLayout.WEST (слева)
BorderLayout.CENTER (заполнить середину до других компонент или до краев)
По умолчанию принимается константа Center.
FlowLayout
FlowLayout менеджер устанавливает компоненты слева направо и при заполнении переходит на строку вниз.
GridLayout
GridLayout это менеджер, который помещает компоненты в таблицу.
GridBagLayout
Этот менеджер подобно GridLayout менеджеру устанавливает компоненты в таблицу, но он более гибок, так как предоставляет возможность определять для компонентов разную ширину и высоту колонок и строк таблицы. По существу, GridBagLayout помещает компоненты в ячейки, и затем использует привилегированные размеры компонентов, чтобы определить, насколько большой ячейка должна быть.
BoxLayout
BoxLayout позволяет управлять размещением компонентов, отдельно в вертикальном либо горизонтальном направлении помещая их, друг за другом, и управлять пространством между компонентами, используя вставки.!!!Иногда важно, чтобы программа выполняла какие- то действия «условно одновременно» Например, одновременно реагировала на действия пользователя в графическом интерфейсе и вела какие-то расчеты, или принимала данные с нескольких других компьютеров, параллельно ведя расчеты
 Кроме этого, потоки дают возможность использовать наличие нескольких процессоров: если в программе всего один поток, он будет выполняться на одном процессоре, остальные будут простаивать
 Поток (thread) – часть многопоточной программы, выполняемая одновременно с другими такими же частями в одном адресном пространстве
 у всех потоков память одна
программа также одна на все потоки
При запуске любой программы создается так называемый главный поток (выполняющий функцию main), главный поток может создавать другие потоки. Oни, в свою очередь, могут создавать дополнительные потоки.
Интерфейс Runnable
 То, что можно выполнить
Содержит единственный метод: void run();
Может использоваться для описания действий, которые должны быть выполнены в отдельном потоке

Класс Thread
 Выполняемый поток
Реализует Runnable: class Thread implements Runnable
Метод run() по умолчанию не делает ничего – должен быть переопределен в производном классе
 Для запуска потока на исполнение служит метод start()!!!Если один поток работает с некоторым объектом, второй поток не может работать с ним в это же время. Следует понимать, что каждый раз, когда поток пытается получить доступ к занятому ресурсу, происходит переключение на другой поток. Если к ресурсу обращаются часто, переключения будут занимать очень много времени
Ключевое слово synchronized используется для указания того, что метод может быть доступен только одним потоком одновременно.
synchronized методы – одновременно вызываются только одной нитью
synchronized(obj) блоки – на время выполнения блока объект obj блокируется
В Java модификатор volatile используется, чтобы позволить знать JVM, что поток доступа к переменной всегда должен объединять свою собственную копию переменной с главной копией в памяти.
Доступ к переменной volatile синхронизирует все кэшированные скопированные переменные в оперативной памяти. Volatile может быть применен только к переменным экземпляра, которые имеют тип объект или private.!!!Класс Object в Java содержит три final метода для взаимодействия потоков. Это методы wait(), notify() и notifyAll(). Зачем это необходимо?
Представим ситуацию, что у нас многопотоковое приложение, написанное на Java. Есть некий класс, выполняющий какое-либо конкретное действие с данными, например, отправку их по почте, а сами данные подготавливаются в другом месте кода в другом потоке. Перед отправкой данных нам необходимо как-то связаться с потоком, подготавливающим данные, дабы поймать момент, когда они будут готовы.
Метод wait()
У метода wait() есть три вариации. Один метод wait() бесконечно ждет другой поток, пока не будет вызван метод notify() или notifyAll() на объекте. Другие две вариации метода wait() ставят текущий поток в ожидание на определенное время. По истечении этого времени поток просыпается и продолжает работу.
Метод notify()
Вызов метод notify() пробуждает только один поток, после чего этот поток начинает выполнение. Если объект ожидают несколько потоков, то метод notify() разбудит только один из них. Выбор потока зависит от системной реализации управления потоками.
Метод notifyAll()
Метод notifyAll() пробуждает все потоки, хотя в какой последовательности они будут пробуждаться зависит от реализации ОС.
Поток, вызывающий эти методы на любом объекте, должен иметь так называемый монитор (механизм многопоточного доступа к объекту). Если же его нет, то будет брошено исключение java.lang.IllegalMonitorStateException!!!Concurrent Collections — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.
Concurrent HashMap использует множество замков и каждый замок управляет одним сегментом структуры. Установки данных в определенном сегменте заблокированы для получения в этом сегменте, синхронизированы операции обновления. При получении данных, чтения на лету используется без синхронизации.
BlockingQueue (блокирующая очередь) - это очередь, которая блокирует поток, в двух случаях:
•	поток пытается получить элементы из пустой очереди
•	поток пытается положить элементы в полную очередь
Когда поток пытается получить элементы из пустой очереди, он ставится в ожидание до тех пор, пока какой-нибудь другой поток не положит элементы в очередь. Аналогично, когда поток пытается положить элементы в полную очередь, он ставится в ожидание до тех пор, пока какой-нибудь другой поток не возьмет элементы их очереди и таким образом не освободит место в ней. Естественно, введение понятия "полная очередь" подразумевает, что очередь имеет ограниченный размер, который обычно задается в конструкторе.
Синхронизированные классы коллекций Hashtable и Vector и синхронизированные классы обрамления Collections.synchronizedMap и Collections.synchronizedList предоставляют базовую условно потокобезопасную реализацию Map и List. Однако несколько факторов делают их непригодными для использования в приложениях с высоким уровнем параллелизма - используемая в них единственная блокировка на всю коллекцию является препятствием для масштабируемости, а зачастую бывает необходимо блокировать коллекцию на значительное время в момент перебора для предотвращения исключений ConcurrentModificationException.
 ConcurrentHashMap и CopyOnWriteArrayList не обязательно полезны везде, где вы могли бы использовать HashMap или ArrayList, но они спроектированы для оптимизации в определённых распространённых ситуациях. Многие параллельные приложения будут в выигрыше от их использования.